# NJOY metaconfigure
The metaconfigure package contains a suite of Python scripts to assist in the generation of build system configuration files for NJOY projects.

## Updating metaconfigure in a project
**Note:** that all the subprojects/dependencies must be updated prior to updating the super project.

These commands (unless otherwise specified) should be run from the top level of a project.
1. Create a branch
2. Download ("fetch") subprojects
   ```bash
   python metaconfigure/fetch_subprojects.py
   ```
3. Update the metaconfigure subtree
   ```bash
   git subtree pull --squash --prefix metaconfigure https://github.com/njoy/metaconfigure.git master
   ```
4. Delete old `description.json` file.
   ```bash
   rm metaconfigure/description.json
   ```
5. Generate new `metaconfigure/description.json` file. This is done in Python.
   ```python
   import metaconfigure
   args = {"name": "project-name", "language": "c++", "is external project": False, "include path": "src/include"}
   metaconfigure.description.generate(**args)
   ```
   Note that the values in `args` need to be appropriate for your particular project. The values given above are just an example.
6. Inspect the new `metaconfigure/description.json`. In particular check:
	- `implementation files`—ensure the correct relative path (to top-level of project) is correct.
	- `header files`—ensure the correct relative path (to top-level of project) is correct.
	- `include path`—ensure that this points to the correct path. This is needed for any C++ project.
7. Generate a [CMake](https://cmake.org) file
   ```bash
   ./metaconfigure/generate.py cmake
   ```
8. Inspect resulting `CMakelists.txt` file
	 - Is the target of the expected type (executable, interface, or library)?
	 
	   An executable target will always be accompanied by a library or interface target in the CMake files generated by metaconfigure. A library target is a collection of soruce file which are to be compiled into a library file (either static or dynamic based on configuration settings) during the build process. This impllies that the project contains one or more implementation files (excluding an implementation file for any executable driver). Those declarations look something like this:
       ```cmake
       add_library( <name> ${<name>_library_linkage} <source files> )
       ```
       
       For targets that lack implementation files (`.cpp` files)—such as header-only libraries—there's nothing to compile. Interface declarations look like
       ```cmake
       add_library( <name> INTERFACE <source files> )
       ```
       
       Given a driver implementation file (defaults to `main.` but can be specified in the description), you should also see an exectuable target which links to the library or interface target.
       ```cmake
       add_executable( <name>_executable <driver> )
	   set_target_properties( <name>_executable PROPERTIES OUTPUT_NAME <name> )
	   target_compile_options( <name>_executable PRIVATE <flags generator expression> )
	   target_link_libraries( <name>_executable <PUBLIC/INTERFACE> <name> )
	   ```
	 - Are the tests specified?
	 - Are the compiler flags specified?
9. Build/test project locally to make sure everything works.
10. Update `.travis.yml` and `.travis.sh`.
11. Push to GitHub.
12. Create pull request.


## License
This software is distributed according to the terms specified in the [LICENSE](LICENSE) file.
